<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<script>
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.Grid = window.Vaadin.Grid || {};

  /**
   * @polymerMixin
   */
  Vaadin.Grid.DataProviderMixin = superClass => class DataProviderMixin extends superClass {

    static get properties() {
      return {

        /**
         * Number of items fetched at a time from the dataprovider.
         */
        pageSize: {
          type: Number,
          value: 50,
          observer: '_pageSizeChanged'
        },

        /**
         * Function that provides items lazily. Receives arguments `params`, `callback`
         *
         * `params.page` Requested page index
         *
         * `params.pageSize` Current page size
         *
         * `params.filters` Currently applied filters
         *
         * `params.sortOrders` Currently applied sorting orders
         *
         */
        dataProvider: {
          type: Object,
          notify: true,
          observer: '_dataProviderChanged'
        },

        /**
         * `true` while data is being requested from the data provider.
         */
        _loading: {
          type: Boolean,
          observer: '_loadingChanged'
        },

        _cache: {
          type: Object,
          value: function() {
            return {};
          }
        },

        _pendingRequests: {
          type: Object,
          value: function() {
            return {};
          }
        },
      };
    }

    _loadingChanged(loading) {
      this._toggleAttribute('loading', loading, this);
    }

    _updateRowItem(item, el) {
      el.children.forEach(cell => {
        cell._instance && (cell._instance.item = item);
      });
    }

    _getItem(index, el) {
      el.index = index;
      const item = this._cache[index];
      if (item) {
        this._updateItem(el, item);
      } else {
        const pageForIndex = this._getPageForIndex(index);
        this._loadPage(pageForIndex);
      }
    }

    // _cachedPagesForPhysicalItems() {
    //   return this._pagesForPhysicalItems().filter(page => this._cache !== undefined && this._cache[page] !== undefined);
    // }
    //
    // _uncachedPagesForPhysicalItems() {
    //   return this._pagesForPhysicalItems().filter(page => this._cache !== undefined && this._cache[page] === undefined);
    // }
    //
    // _eagerlyLoadPages() {
    //   const pages = this._cachedPagesForPhysicalItems().slice(0);
    //
    //   if (pages.length > 0) {
    //     pages.sort((a, b) => a > b);
    //
    //     const prev = Math.max(0, pages[0] - 1);
    //     const next = Math.min(pages[pages.length - 1] + 1, Math.max(0, Math.floor(this.size / this.pageSize) - 1));
    //
    //     this._loadPage(prev);
    //     this._loadPage(next);
    //   }
    // }

    _pagesForPhysicalItems() {
      // TODO: potentially heavy operation to run first visible index,
      // reconsider if performance issues occur on data binding / scrolling.
      // TODO: _vidxOffset shouldn't be read from here.
      const firstVisiblePage = this._getPageForIndex(this._firstVisibleIndex + this._vidxOffset);

      return [firstVisiblePage].concat(
        this._physicalItems
          .filter(row => row.index)
          .map(row => this._getPageForIndex(row.index))
        ).reduce((prev, curr) => {
          if (prev.indexOf(curr) === -1) {
            prev.push(curr);
          }

          return prev;
        }, []);
    }

    _canPopulate() {
      return this._hasData;
    }

    _loadPage(page) {

      // make sure same page isn't requested multiple times.
      if (!this._pendingRequests[page] && this.dataProvider) {
        this._pendingRequests[page] = true;
        const params = {
          page: page,
          pageSize: this.pageSize,
          sortOrders: this._mapSorters(),
          filters: this._mapFilters()
        };

        this.dataProvider(params, (items) => {
          items.forEach((item, itemsIndex) => {
            this._cache[page * this.pageSize + itemsIndex] = item;
          });

          Array.from(this.$.items.children).forEach(row => {
            const cachedItem = this._cache[row.index];
            if (items.indexOf(cachedItem) > -1) {
              this._updateItem(row, cachedItem);
            }
          });

          this._hasData = true;
          this._increasePoolIfNeeded();

          delete this._pendingRequests[page];

          this._loading = this._pendingRequests.length > 0;
        });
      }
    }

    _getPageForIndex(index) {
      return Math.floor(index / this.pageSize);
    }

    /**
     * Clears the cached pages and reloads data from dataprovider when needed.
     */
    clearCache() {
      this._cache = {};
      this._pendingRequests = {};
      this._hasData = false;
      this._loading = true;
      this._assignModels();
    }

    _flushItemsDebouncer() {
      if (this._debouncerLoad) {
        this._debouncerLoad.flush();
      }
    }

    _pageSizeChanged(pageSize, oldPageSize) {
      if (oldPageSize !== undefined && pageSize !== oldPageSize) {
        this.clearCache();
      }
    }

    _checkSize() {
      if (this.size === undefined) {
        console.warn('The <vaadin-grid> needs a value for "size" property in order to display rows.');
      }
    }

    _dataProviderChanged(dataProvider, oldDataProvider) {
      if (oldDataProvider !== undefined) {
        this.clearCache();
      }

      if (dataProvider && this.items && this.items.length) {
        // Fixes possibly invalid cached lastVisibleIndex value in <iron-list>
        this._scrollToIndex(this._firstVisibleIndex);
      }

      if (!this._hasData) {
        // load data before adding rows to make sure they have content when
        // rendered for the first time.
        this._loading = true;
        this._loadPage(0, () => {
          const hadData = this._hasData;
          this._hasData = true;
          if (!hadData) {
            this.notifyResize();
          }
        });
      }

      this._debouncerCheckSize = Polymer.Debouncer.debounce(
        this._debouncerCheckSize,
        Polymer.Async.timeOut.after(2000),
        this._checkSize.bind(this));
      //
      // if (dataProvider && this.items && this.items.length) {
      //   // Fixes possibly invalid cached lastVisibleIndex value in <iron-list>
      //   this._scrollToIndex(this._firstVisibleIndex);
      // }
    }

  };
</script>
